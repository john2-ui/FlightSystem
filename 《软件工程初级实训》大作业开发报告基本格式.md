# 《软件工程初级实训》大作业开发报告基本格式

（ 项目名称 ）项目开发报告

1.项目概述

**基本内容：****使用Q**t+MySQL完成的航班票务管**理系统**

**主要参加人员**

**组    长：**   陈科年     **成员：**张万里、黄俊杰、胡江龙

**业绩权重说明**：均分（1 1 1 1）

**工作任务的分解和人员分工：**

陈科年：负责项目前期规划与分工，帮助协作组内配合。负责完成项目中的MySQL数据库各个部分的模型设计，包括flight,ticket,airport等，对外接口，以及DAO层（数据库与后端部分的交互层）。负责项目README维护与更新

张万里：（自填）

黄俊杰： 负责项目管理端界面的开发，设计了整个管理端界面以及功能，为程序整体的美术风格与设计定调。进行了管理端功能的测试并找出了后端实现中部分漏洞。

胡江龙：负责后端业务逻辑层（Backend）的开发与设计，实现了单例模式下的业务调度中心。负责跨模块的业务逻辑编排、数据库事务管理、用户权限校验以及票务初始化逻辑。协助 DAO 层的接口定义与性能优化建议。

**创新点 或技术难点 说明（如果有的话）**

1.  使用qmake+子项目组合的模式进行开发，使得各个部分之间独立，不冲突，且更加方便成员单独开发调试，以及最后的整合
    
2.  数据库部分将flight模型内部的机场(airport)以及机票(ticket)进行了独立分割，使用id进行链接，使得数据模型更加轻量
    
3.  如果其他人有添加，请删除这一行并添加
    

2.业务需求分析和基本功能

1.  项目目标
    
    1.  提供可视化、易操作的桌面票务管理系统
        
    2.  实现航班与票务数据的集中存储与统一管理
        
    3.  提高航班查询与售票效率
        
    4.  减少人工操作错误，保证数据一致性与安全性
    
2.  系统使用角色分析
    
    1.  管理员
        
        1.  维护系统基础数据
            
        2.  管理航班、飞机、票价等信息
        
    2.  普通用户 / 旅客（User）
        
        1.  查询航班
            
        2.  购票
            
        3.  查看订单
            
        4.  退票 / 改签
    
3.  系统核心业务需求
    
    1.  业务需求
        
        1.  系统支持用户登录与注册
            
        2.  不同角色拥有不同的操作权限
        
    2.  业务规则
        
        1.  用户id为一，用户名可重复
            
        2.  管理员拥有更改后台航班票务等信息的权限
        
    3.  航班信息管理
        
        1.  对航班信息最基本的CRUD
        
    4.  航班基本信息
        
        1.  航班号
            
        2.  起飞城市/到达城市
            
        3.  起飞机场/到达机场
            
        4.  飞机型号
            
        5.  总票座数
            
        6.  剩余票座数
            
        7.  三种座位以及对应价格
            
        8.  航班目前状态
        
    5.  业务规则
        
        1.  航班号唯一
            
        2.  起飞时间必须早于到达时间
            
        3.  剩余票座数<=总座位数
    
4.  航班查询需求
    
    1.  业务需求：用户能够根据不同条件快速查询可用航班
        
    2.  功能点
        
        1.  按城市查询
            
        2.  按日期查询
            
        3.  按价格排序
            
        4.  按起飞时间排序
    
5.  订票业务需求
    
    1.  业务需求
        
        1.  支持用户购买航班机票。
        
    2.  功能点
        
        1.  选择航班
            
        2.  填写旅客信息
            
        3.  提交订单
            
        4.  自动减少航班余票
    
6.  如果其他人有添加，请删除这一行并添加
    

3.系统设计与实现

1.  计算机体系设计（采用技术和平台）
    
    1.  使用Qt+MySQL实现了跨平台应用程序，可在MacOS,Windows,Linux等主流的桌面端操作系统使用，且使用体验良好无差异
        

1.  功能详细设计与数据库字典
    

## 数据库字典

### 1. 城市表 `city`

**表说明**：

存储城市的基本信息，为机场提供所属城市的外键支持。

| 字段名 | 类型 | 是否为空 | 主键 | 默认值 | 说明 |
| --- | --- | --- | --- | --- | --- |
| id | INT | 否 | 是 | 自增 | 城市唯一标识 |
| name | VARCHAR(50) | 否 | 否 |  | 城市名称 |
| code | VARCHAR(10) | 是 | 否 |  | 城市代码 |
| country | VARCHAR(50) | 是 | 否 |  | 所属国家 |

---

### 2. 机场表 `airport`

**表说明**：

存储机场基本信息，每个机场隶属于一个城市。

| 字段名 | 类型 | 是否为空 | 主键 | 默认值 | 说明 |
| --- | --- | --- | --- | --- | --- |
| id | INT | 否 | 是 | 自增 | 机场唯一标识 |
| name | VARCHAR(100) | 否 | 否 |  | 机场名称 |
| code | VARCHAR(10) | 否 | 否 |  | 机场三字码（如 CAN） |
| city\_id | INT | 否 | 否 |  | 所属城市 ID |
| terminal\_count | INT | 是 | 否 | 1 | 航站楼数量 |

**外键约束**：

*   `city_id` → `city(id)`
    

---

### 3. 飞机表 `airplane`

**表说明**：

记录飞机型号及其不同舱位的座位数量，用于航班运力配置。

| 字段名 | 类型 | 是否为空 | 主键 | 默认值 | 说明 |
| --- | --- | --- | --- | --- | --- |
| id | INT | 否 | 是 | 自增 | 飞机唯一标识 |
| model | VARCHAR(50) | 否 | 否 |  | 飞机型号（如 A320） |
| seats\_economy | INT | 是 | 否 | 0 | 经济舱座位数 |
| seats\_business | INT | 是 | 否 | 0 | 商务舱座位数 |
| seats\_first | INT | 是 | 否 | 0 | 头等舱座位数 |

---

### 4. 航班表 `flight`

**表说明**：

记录具体航班信息，包括起降机场、时间、飞机及航班状态。

| 字段名 | 类型 | 是否为空 | 主键 | 默认值 | 说明 |
| --- | --- | --- | --- | --- | --- |
| id | INT | 否 | 是 | 自增 | 航班唯一标识 |
| flight\_no | VARCHAR(10) | 否 | 否 |  | 航班号（如 CZ3101） |
| airplane\_id | INT | 否 | 否 |  | 执行飞机 ID |
| depart\_airport\_id | INT | 否 | 否 |  | 出发机场 |
| arrive\_airport\_id | INT | 否 | 否 |  | 到达机场 |
| depart\_time | DATETIME | 否 | 否 |  | 起飞时间 |
| arrive\_time | DATETIME | 否 | 否 |  | 到达时间 |
| status | VARCHAR(20) | 是 | 否 | normal | 航班状态 |

**状态字段说明（status）**：

| 值 | 含义 |
| --- | --- |
| normal | 正常 |
| delayed | 延误 |
| cancelled | 取消 |

**外键约束**：

*   `airplane_id` → `airplane(id)`
    
*   `depart_airport_id` → `airport(id)`
    
*   `arrive_airport_id` → `airport(id)`
    

---

### 5. 机票表 `ticket`

**表说明**：

记录航班对应的舱位类型、票价及余票信息。

| 字段名 | 类型 | 是否为空 | 主键 | 默认值 | 说明 |
| --- | --- | --- | --- | --- | --- |
| id | INT | 否 | 是 | 自增 | 机票唯一标识 |
| flight\_id | INT | 否 | 否 |  | 所属航班 ID |
| class | ENUM | 否 | 否 |  | 舱位类型 |
| price | DECIMAL(10,2) | 否 | 否 |  | 票价 |
| total\_seats | INT | 否 | 否 |  | 总座位数 |
| remain\_seats | INT | 否 | 否 |  | 剩余座位数 |

**舱位枚举说明（class）**：

| 值 | 含义 |
| --- | --- |
| economy | 经济舱 |
| business | 商务舱 |
| first | 头等舱 |

**外键约束**：

*   `flight_id` → `flight(id)`
    

---

### 6. 用户表 `user`

**表说明**：

存储系统用户与管理员信息，用于登录与权限控制。

| 字段名 | 类型 | 是否为空 | 主键 | 默认值 | 说明 |
| --- | --- | --- | --- | --- | --- |
| id | INT | 否 | 是 | 自增 | 用户唯一标识 |
| username | VARCHAR(255) | 否 | 否 |  | 用户名（唯一） |
| password | VARCHAR(255) | 否 | 否 |  | 用户密码 |
| tickets\_id | TEXT | 否 | 否 |  | 用户已购机票 ID（逗号分隔） |
| isSuper | TINYINT(1) | 否 | 否 | 0 | 是否管理员 |

**权限字段说明（isSuper）**：

| 值 | 含义 |
| --- | --- |
| 0 | 普通用户 |
| 1 | 管理员 |

## 详细功能设计(后端部分)

后端核心类 `Backend` 承担了系统业务逻辑的编排与调度，其设计遵循高内聚、低耦合的原则，具体设计细节如下：

### 1. 架构设计与模式
*   **单例模式 (Singleton)**：`Backend` 类被设计为全局唯一的单例，作为 UI 层与数据访问层（DAO）之间的唯一桥梁。这种设计确保了数据库连接池（`DBManager`）的统一管理，并避免了多个业务实例导致的状态不一致。
*   **分层解耦**：后端位于 DAO 层之上，UI 层之下。它不直接操作 SQL 语句，而是通过调用各个 DAO 接口（如 `FlightDao`, `TicketDao`）来获取原子数据，并在后端进行业务逻辑的组装。

### 2. 核心业务逻辑设计
*   **航班详情聚合逻辑**：
    由于数据库采用规范化设计，航班、机场、城市、飞机和机票信息分散在不同表中。后端设计了 `getFlightDetail` 接口，通过多步 DAO 调用，将这些离散数据聚合为 `FlightDetailInfo` 对象。这包括：
    1.  根据航班 ID 获取基础信息。
    2.  关联查询出发/到达机场及其所属城市。
    3.  查询执行飞机的型号。
    4.  筛选并封装该航班下的所有舱位机票信息（经济、商务、头等）。
*   **自动化票务生成设计**：
    在管理员添加航班（`addFlight`）时，后端设计了自动触发机制。系统会读取所选飞机的座位配置，自动为该航班生成三组机票记录。设计中包含了**分舱位定价逻辑**，允许管理员在创建航班时直接指定不同舱位的价格。
*   **购票与退票事务流**：
    购票（`purchaseTicket`）和退票（`refundTicket`）是系统的核心高风险操作。后端设计了严谨的事务流：
    1.  **预校验**：检查用户状态、航班状态及余票是否充足。
    2.  **原子操作**：开启数据库事务，同步更新 `ticket` 表的余票字段和 `user` 表的已购机票 ID 列表。
    3.  **异常处理**：若任何一步失败，立即执行回滚，确保系统不会出现“有票无单”或“有单无票”的异常状态。
*   **用户安全与注销逻辑**：
    系统设计了基于“软删除”的用户注销机制。后端在处理 `deleteUser` 时，不会物理删除记录，而是通过 `Tombstone`（墓碑）策略：将用户名修改为 `原名#deleted_时间戳`，并将 `isSuper` 标记为 `-1`。这种设计既保证了历史订单的外键引用完整性，又实现了账号的逻辑失效。

### 3. 数据结构设计
后端定义了一系列 DTO（数据传输对象）用于与前端交互：
*   **`TicketInfo`**：封装单张机票的 ID、舱位、价格及实时余票。
*   **`FlightDetailInfo`**：系统中最复杂的结构，包含了航班的所有静态属性（航司、时间、地点）和动态属性（各舱位实时状态）。

## 编码实现（重点模块）

### 编码实现（数据库部分）

1.  根据数据字典部分，大部分数据表之间使用了一对多的关系进行连接
    
2.  数据库部分先设计了不同数据表对应的model（项目中的Model文件中可以查看）
    
3.  然后根据model板块各个model的类设计完成了对应的DAO层，封装了对MySQL中各个模块的CRUD，并对后端暴露必要的CRUD接口，以便后端调用
    
4.  各个模块之间在数据库封装部分并无关系，各个model之间是完全独立的，所有的model之间的交互以及连接逻辑都交由后端部分完成
    

#### 编码实现（后端部分）

*   **单例模式与资源生命周期管理**
    后端核心类 `Backend` 采用了严格的单例模式实现。通过 `static Backend& instance()` 接口，利用 C++11 局部静态变量的线程安全特性，确保了整个程序生命周期内业务逻辑层的唯一性。
    ```cpp
    // 单例模式实现
    Backend& Backend::instance() {
        static Backend instance;
        return instance;
    }

    // 构造函数中统一初始化 DAO 资源
    Backend::Backend() {
        cityDao = new CityDaoImpl();
        airportDao = new AirportDaoImpl();
        airplaneDao = new AirplaneDaoImpl();
        flightDao = new FlightDaoImpl();
        ticketDao = new TicketDaoImpl();
        userDao = new UserDaoImpl();
    }
    ```

*   **复杂业务对象的聚合实现 (`getFlightDetail`)**
    由于数据库遵循第三范式设计，单一的航班 ID 无法直接提供用户所需的完整信息。后端实现了深度聚合逻辑，将离散的表数据封装为 `FlightDetailInfo`：
    ```cpp
    FlightDetailInfo Backend::getFlightDetail(int flightId) {
        FlightDetailInfo info;
        Flight flight = flightDao->getById(flightId); // 1. 获取基础航班
        if (flight.id() == 0) return info;

        // 2. 聚合机场与城市信息
        Airport departAirport = airportDao->getById(flight.departAirportId());
        City departCity = cityDao->getById(departAirport.cityId());
        info.departCityName = departCity.name();
        info.departAirportName = departAirport.name();

        // 3. 聚合机型信息
        Airplane airplane = airplaneDao->getById(flight.airplaneId());
        info.airplaneModel = airplane.model();

        // 4. 聚合票务实时信息
        QList<Ticket> allTickets = ticketDao->getAll();
        for (const Ticket& ticket : allTickets) {
            if (ticket.flightId() == flightId) {
                TicketInfo tInfo = { ticket.id(), ticket.tClass(), ticket.price(), ... };
                info.tickets[ticket.tClass()] = tInfo;
            }
        }
        return info;
    }
    ```

*   **基于事务的票务安全机制 (`purchaseTicket`)**
    在处理购票等涉及数据一致性的操作时，后端通过显式开启数据库事务，确保了操作的原子性：
    ```cpp
    bool Backend::purchaseTicket(int userId, int ticketId, int quantity, QString& errorMsg) {
        // ... 预校验逻辑 ...
        QSqlDatabase db = DBManager::instance().db();
        if (!db.transaction()) return false; // 开启事务

        // 1. 扣减余票
        if (!bookTicket(flight.id(), ticket.tClass(), quantity, bookError)) {
            db.rollback(); // 失败回滚
            return false;
        }

        // 2. 更新用户订单记录
        QVector<int> tickets = user.ticketsID();
        for (int i = 0; i < quantity; ++i) tickets.append(ticket.id());
        user.setTicketsID(tickets);

        if (!userDao->update(user)) {
            db.rollback(); // 失败回滚
            return false;
        }
        return db.commit(); // 全部成功则提交
    }
    ```

*   **航班与票务的联动初始化 (`addFlight`)**
    当管理员新增航班时，后端实现了自动化的票务生成逻辑，根据飞机布局自动创建机票记录：
    ```cpp
    // 自动生成三舱机票
    const struct TicketSeed {
        QString klass; int seats; double price;
    } ticketSeeds[] = {
        {QStringLiteral("economy"), airplane.seatsEconomy(), priceEconomy},
        {QStringLiteral("business"), airplane.seatsBusiness(), priceBusiness},
        {QStringLiteral("first"), airplane.seatsFirst(), priceFirst}
    };

    for (const TicketSeed& seed : ticketSeeds) {
        if (seed.seats <= 0) continue;
        Ticket ticket(0, flightId, seed.klass, seed.price, seed.seats, seed.seats);
        ticketDao->insert(ticket); // 批量初始化机票
    }
    ```

*   **用户体系与“软删除”策略 (`deleteUser`)**
    为了保持数据库引用的完整性，后端采用了“墓碑记录（Tombstone）”策略处理用户注销：
    ```cpp
    bool Backend::deleteUser(int userId, QString& errorMsg) {
        User user = userDao->getById(userId);
        // 生成墓碑用户名：原名#deleted_时间戳
        const QString tombStone = QStringLiteral("%1#deleted_%2")
                                      .arg(user.username())
                                      .arg(QDateTime::currentMSecsSinceEpoch());
        user.setUsername(tombStone);
        user.setPassword(""); // 清空敏感信息
        user.setIsSuper(-1);  // 标记为注销状态
        return userDao->update(user);
    }
    ```

*   **级联删除逻辑的实现 (`deleteFlight`)**
    在数据库设计中，`ticket` 表通过外键关联到 `flight` 表。为了解决直接删除航班时触发的外键约束冲突，后端在 `deleteFlight` 中实现了级联删除逻辑，并封装在事务中：
    ```cpp
    bool Backend::deleteFlight(int flightId, QString& errorMsg) {
        QSqlDatabase db = DBManager::instance().db();
        if (!db.transaction()) return false;

        // 1. 先删除关联机票，解除外键依赖
        if (!ticketDao->removeByFlightId(flightId)) {
            db.rollback();
            return false;
        }

        // 2. 再删除航班主体
        if (!flightDao->remove(flightId)) {
            db.rollback();
            return false;
        }
        return db.commit();
    }
    ```

#### 编码实现（客户端界面）

请张万里填写

#### 编码实现（管理端界面）

1.  通过menubar以及stackWidget控件实现不同功能界面之间的切换，使用槽函数连接界面切换信号，并对界面进行初始化。
    
2.  通过groupbox控件存储界面中的各个控件，使得不同控件之间排列有序，美观。
    
3.  使用spinbox控件，在搜索航班时既支持通过条件搜索也支持直接输入航班ID进行搜索。
    

4.系统测试

(张万里与黄俊杰共同填写)

请张万里测试并填写客户端所有的操作，请黄俊杰测试并填写管理端所有操作，可插入截图展示

*   添加航班界面及添加成功截图：![{76E87929-C53E-41E5-8E9F-DFFB1FC93E1D}.png](https://alidocs.oss-cn-zhangjiakou.aliyuncs.com/res/4EZlweZrm94YWqxA/img/49c28b4d-5cb2-4366-8f6a-ab1be1f49e37.png)![{0FF2D510-CF17-45E6-A7BB-750F25FEC9B3}.png](https://alidocs.oss-cn-zhangjiakou.aliyuncs.com/res/4EZlweZrm94YWqxA/img/ac6a9e8d-f5ea-4401-b142-6dbf45c09fd2.png)
    

5.项目展望

本航班票务管理系统基于 Qt 与 MySQL 实现，完成了城市、机场、航班、机票及用户等核心业务模块的设计与实现，基本满足了航班信息管理与机票查询、购票等功能需求。通过本项目的开发，加深了对关系型数据库设计、外键约束、以及前后端业务逻辑协同的理解，具备一定的实际应用价值。

在未来的改进与扩展中，系统仍具有较大的优化空间。首先，在数据库设计方面，可进一步规范数据结构，例如将用户与机票之间的关系拆分为独立的关联表，以减少数据冗余并提高系统的可维护性。其次，在业务功能上，可引入订单管理、支付状态、退改签机制等模块，使系统更贴近真实航班票务业务场景。

此外，在系统架构层面，后续可考虑引入更完善的权限管理机制，实现用户与管理员的细粒度权限控制；同时通过增加日志记录与异常处理机制，提高系统的稳定性与安全性。在性能与扩展性方面，也可探索引入缓存机制或接口化设计，为未来系统向 Web 化或分布式方向演进奠定基础。

总体而言，本项目为航班票务管理系统的进一步完善和扩展提供了良好的基础，具有较强的学习价值和实践意义。

_（报告最晚提交时间 第十八周周日晚8点前，最好在展示时同时提交，需打印，作为文档留存）_